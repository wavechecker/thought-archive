---
import Layout from "@/layouts/Layout.astro";
import { getCollection, getEntryBySlug, type CollectionEntry } from "astro:content";
import { isValidDate, fmt } from "@/lib/date";

export const prerender = true;

// ---------- types & helpers ----------
type Guide = CollectionEntry<"guides">;

const toStringSlug = (param: string | string[] | undefined): string =>
  Array.isArray(param) ? param.join("/") : String(param ?? "");

// âœ… Make TS aware that params.slug exists at runtime
type CatchAllParams = { slug?: string | string[] };
const slug = toStringSlug((Astro.params as unknown as CatchAllParams).slug);

/**
 * For a catch-all route like [...slug], return a STRING param for each page.
 * Astro v5 is happy with "section/child" style slugs here.
 */
export async function getStaticPaths() {
  const entries = await getCollection("guides");
  return entries.map((e) => ({
    params: { slug: e.slug }, // may include "/" for nested paths
  }));
}

// Fetch entry (slug may be nested, e.g., "section/guide-name")
const entry = (await getEntryBySlug("guides", slug)) as Guide | null;

if (!entry) {
  Astro.response.status = 404;
  throw new Error(`[guides] No entry found for slug: ${slug}`);
}

const { Content } = await entry.render();
const data = entry.data;
const canonical = `https://patientguide.io/guides/${entry.slug}/`;

// Resolve "Related Guides" from frontmatter `related` ("/guides/foo" or "foo")
const allGuides = await getCollection("guides");

function resolveRelated(rel: unknown): Guide[] {
  if (!Array.isArray(rel)) return [];
  return rel
    .map((r) => (typeof r === "string" ? r : null))
    .filter(Boolean)
    .map((r) => r!.replace(/^\/guides\//, "").replace(/\/$/, ""))
    .map((key) => allGuides.find((e) => e.slug === key) ?? null)
    .filter((e): e is Guide => Boolean(e));
}
const related = resolveRelated((data as any).related);
---




