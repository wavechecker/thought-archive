---
import Layout from "@/layouts/Layout.astro";
import { getCollection } from "astro:content";
import { isValidDate, fmt } from "@/lib/date";

/** Map a human category → URL-safe segment used in paths */
function catToSegment(cat: unknown): string {
  return String(cat ?? "")
    .toLowerCase()
    .trim()
    .replace(/&/g, "and")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

/** Prefer data.slug when present; else derive from filename */
function entrySlug(e: any): string {
  const s = e?.data?.slug || e?.slug || "";
  return String(s).split("/").pop();
}

/** Build-time paths for ALL guides with category + slug */
export async function getStaticPaths() {
  const guides = await getCollection("guides");
  return guides.map((e) => {
    const category = catToSegment(e.data?.category);
    const slug = entrySlug(e);
    return {
      params: { category, slug },
      props: { _slug: slug }, // we’ll look the entry up by this later
    };
  });
}

/** Pull all guides to resolve the one we need + related, etc. */
const allGuides = await getCollection("guides");
const { slug: routeSlug } = Astro.params;

/** Find the guide by matching data.slug (preferred) or filename slug */
const entry =
  allGuides.find((e) => (e.data?.slug || "").split("/").pop() === routeSlug) ||
  allGuides.find((e) => (e.slug || "").split("/").pop() === routeSlug);

if (!entry) {
  // If something ever mismatches, send people to /guides/
  return Astro.redirect("/guides/");
}

const { Content } = await entry.render();
const data = entry.data;

// Canonical: include category segment
const categorySeg = catToSegment(data?.category);
const canonicalUrl = `https://patientguide.io/guides/${categorySeg}/${entrySlug(entry)}/`;

/** Resolve "Related Guides" from frontmatter.related (array of /guides/<slug>) */
function resolveRelated(rel) {
  if (!Array.isArray(rel)) return [];
  const clean = (r) => String(r).replace(/^\/guides\//, "").replace(/\/$/, "");
  return rel
    .map((r) => {
      const key = clean(r);
      return allGuides.find((e) => entrySlug(e) === key);
    })
    .filter(Boolean);
}
const related = resolveRelated(data.related);
---

<Layout frontmatter={{ ...data, canonicalUrl }}>
  <h1>{data?.title ?? "Untitled"}</h1>
  <p style="color:#6b7280; margin-top:.25rem;">
    {data?.publishDate && isValidDate(data.publishDate) ? fmt(data.publishDate) : ""}
    {data?.updatedDate && isValidDate(data.updatedDate) ? ` • Updated ${fmt(data.updatedDate)}` : ""}
  </p>

  <Content />

  {related.length > 0 && (
    <>
      <h2>Related Guides</h2>
      <ul>
        {related.map((r) => {
          const cat = catToSegment(r.data?.category);
          const s = entrySlug(r);
          return <li><a href={`/guides/${cat}/${s}/`}>{r.data.title}</a></li>;
        })}
      </ul>
    </>
  )}

  {data?.tags?.length > 0 && (
    <p style="color:#2563eb; margin-top:1rem;">
      {data.tags.map((t, i) => `#${t}${i < data.tags.length - 1 ? " " : ""}`)}
    </p>
  )}
</Layout>
